// Code generated by SQLBoiler 4.6.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Company is an object representing the database table.
type Company struct {
	ID            uint        `boil:"id" json:"id" toml:"id" yaml:"id"`
	Type          int         `boil:"type" json:"type" toml:"type" yaml:"type"`
	Name          string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	PostCode      null.String `boil:"post_code" json:"post_code,omitempty" toml:"post_code" yaml:"post_code,omitempty"`
	Address       null.String `boil:"address" json:"address,omitempty" toml:"address" yaml:"address,omitempty"`
	Tel           null.String `boil:"tel" json:"tel,omitempty" toml:"tel" yaml:"tel,omitempty"`
	CreatedAt     null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt     null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	SiteID        uint        `boil:"site_id" json:"site_id" toml:"site_id" yaml:"site_id"`
	Code          null.String `boil:"code" json:"code,omitempty" toml:"code" yaml:"code,omitempty"`
	Homepage      null.String `boil:"homepage" json:"homepage,omitempty" toml:"homepage" yaml:"homepage,omitempty"`
	CycleID       null.Uint64 `boil:"cycle_id" json:"cycle_id,omitempty" toml:"cycle_id" yaml:"cycle_id,omitempty"`
	PaymentWayID  null.Uint64 `boil:"payment_way_id" json:"payment_way_id,omitempty" toml:"payment_way_id" yaml:"payment_way_id,omitempty"`
	SendWayID     null.Uint64 `boil:"send_way_id" json:"send_way_id,omitempty" toml:"send_way_id" yaml:"send_way_id,omitempty"`
	PaymentDateID null.Uint64 `boil:"payment_date_id" json:"payment_date_id,omitempty" toml:"payment_date_id" yaml:"payment_date_id,omitempty"`
	InvoiceFormID null.Uint64 `boil:"invoice_form_id" json:"invoice_form_id,omitempty" toml:"invoice_form_id" yaml:"invoice_form_id,omitempty"`
	DeletedAt     null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	Note          null.String `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	OrderDate     null.String `boil:"order_date" json:"order_date,omitempty" toml:"order_date" yaml:"order_date,omitempty"`

	R *companyR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L companyL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CompanyColumns = struct {
	ID            string
	Type          string
	Name          string
	PostCode      string
	Address       string
	Tel           string
	CreatedAt     string
	UpdatedAt     string
	SiteID        string
	Code          string
	Homepage      string
	CycleID       string
	PaymentWayID  string
	SendWayID     string
	PaymentDateID string
	InvoiceFormID string
	DeletedAt     string
	Note          string
	OrderDate     string
}{
	ID:            "id",
	Type:          "type",
	Name:          "name",
	PostCode:      "post_code",
	Address:       "address",
	Tel:           "tel",
	CreatedAt:     "created_at",
	UpdatedAt:     "updated_at",
	SiteID:        "site_id",
	Code:          "code",
	Homepage:      "homepage",
	CycleID:       "cycle_id",
	PaymentWayID:  "payment_way_id",
	SendWayID:     "send_way_id",
	PaymentDateID: "payment_date_id",
	InvoiceFormID: "invoice_form_id",
	DeletedAt:     "deleted_at",
	Note:          "note",
	OrderDate:     "order_date",
}

var CompanyTableColumns = struct {
	ID            string
	Type          string
	Name          string
	PostCode      string
	Address       string
	Tel           string
	CreatedAt     string
	UpdatedAt     string
	SiteID        string
	Code          string
	Homepage      string
	CycleID       string
	PaymentWayID  string
	SendWayID     string
	PaymentDateID string
	InvoiceFormID string
	DeletedAt     string
	Note          string
	OrderDate     string
}{
	ID:            "companies.id",
	Type:          "companies.type",
	Name:          "companies.name",
	PostCode:      "companies.post_code",
	Address:       "companies.address",
	Tel:           "companies.tel",
	CreatedAt:     "companies.created_at",
	UpdatedAt:     "companies.updated_at",
	SiteID:        "companies.site_id",
	Code:          "companies.code",
	Homepage:      "companies.homepage",
	CycleID:       "companies.cycle_id",
	PaymentWayID:  "companies.payment_way_id",
	SendWayID:     "companies.send_way_id",
	PaymentDateID: "companies.payment_date_id",
	InvoiceFormID: "companies.invoice_form_id",
	DeletedAt:     "companies.deleted_at",
	Note:          "companies.note",
	OrderDate:     "companies.order_date",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var CompanyWhere = struct {
	ID            whereHelperuint
	Type          whereHelperint
	Name          whereHelperstring
	PostCode      whereHelpernull_String
	Address       whereHelpernull_String
	Tel           whereHelpernull_String
	CreatedAt     whereHelpernull_Time
	UpdatedAt     whereHelpernull_Time
	SiteID        whereHelperuint
	Code          whereHelpernull_String
	Homepage      whereHelpernull_String
	CycleID       whereHelpernull_Uint64
	PaymentWayID  whereHelpernull_Uint64
	SendWayID     whereHelpernull_Uint64
	PaymentDateID whereHelpernull_Uint64
	InvoiceFormID whereHelpernull_Uint64
	DeletedAt     whereHelpernull_Time
	Note          whereHelpernull_String
	OrderDate     whereHelpernull_String
}{
	ID:            whereHelperuint{field: "`companies`.`id`"},
	Type:          whereHelperint{field: "`companies`.`type`"},
	Name:          whereHelperstring{field: "`companies`.`name`"},
	PostCode:      whereHelpernull_String{field: "`companies`.`post_code`"},
	Address:       whereHelpernull_String{field: "`companies`.`address`"},
	Tel:           whereHelpernull_String{field: "`companies`.`tel`"},
	CreatedAt:     whereHelpernull_Time{field: "`companies`.`created_at`"},
	UpdatedAt:     whereHelpernull_Time{field: "`companies`.`updated_at`"},
	SiteID:        whereHelperuint{field: "`companies`.`site_id`"},
	Code:          whereHelpernull_String{field: "`companies`.`code`"},
	Homepage:      whereHelpernull_String{field: "`companies`.`homepage`"},
	CycleID:       whereHelpernull_Uint64{field: "`companies`.`cycle_id`"},
	PaymentWayID:  whereHelpernull_Uint64{field: "`companies`.`payment_way_id`"},
	SendWayID:     whereHelpernull_Uint64{field: "`companies`.`send_way_id`"},
	PaymentDateID: whereHelpernull_Uint64{field: "`companies`.`payment_date_id`"},
	InvoiceFormID: whereHelpernull_Uint64{field: "`companies`.`invoice_form_id`"},
	DeletedAt:     whereHelpernull_Time{field: "`companies`.`deleted_at`"},
	Note:          whereHelpernull_String{field: "`companies`.`note`"},
	OrderDate:     whereHelpernull_String{field: "`companies`.`order_date`"},
}

// CompanyRels is where relationship names are stored.
var CompanyRels = struct {
	Cycle       string
	InvoiceForm string
	PaymentDate string
	PaymentWay  string
	SendWay     string
}{
	Cycle:       "Cycle",
	InvoiceForm: "InvoiceForm",
	PaymentDate: "PaymentDate",
	PaymentWay:  "PaymentWay",
	SendWay:     "SendWay",
}

// companyR is where relationships are stored.
type companyR struct {
	Cycle       *Cycle       `boil:"Cycle" json:"Cycle" toml:"Cycle" yaml:"Cycle"`
	InvoiceForm *InvoiceForm `boil:"InvoiceForm" json:"InvoiceForm" toml:"InvoiceForm" yaml:"InvoiceForm"`
	PaymentDate *PaymentDate `boil:"PaymentDate" json:"PaymentDate" toml:"PaymentDate" yaml:"PaymentDate"`
	PaymentWay  *PaymentWay  `boil:"PaymentWay" json:"PaymentWay" toml:"PaymentWay" yaml:"PaymentWay"`
	SendWay     *SendWay     `boil:"SendWay" json:"SendWay" toml:"SendWay" yaml:"SendWay"`
}

// NewStruct creates a new relationship struct
func (*companyR) NewStruct() *companyR {
	return &companyR{}
}

// companyL is where Load methods for each relationship are stored.
type companyL struct{}

var (
	companyAllColumns            = []string{"id", "type", "name", "post_code", "address", "tel", "created_at", "updated_at", "site_id", "code", "homepage", "cycle_id", "payment_way_id", "send_way_id", "payment_date_id", "invoice_form_id", "deleted_at", "note", "order_date"}
	companyColumnsWithoutDefault = []string{"type", "name", "post_code", "address", "tel", "created_at", "updated_at", "site_id", "code", "homepage", "cycle_id", "payment_way_id", "send_way_id", "payment_date_id", "invoice_form_id", "deleted_at", "note", "order_date"}
	companyColumnsWithDefault    = []string{"id"}
	companyPrimaryKeyColumns     = []string{"id"}
)

type (
	// CompanySlice is an alias for a slice of pointers to Company.
	// This should almost always be used instead of []Company.
	CompanySlice []*Company
	// CompanyHook is the signature for custom Company hook methods
	CompanyHook func(context.Context, boil.ContextExecutor, *Company) error

	companyQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	companyType                 = reflect.TypeOf(&Company{})
	companyMapping              = queries.MakeStructMapping(companyType)
	companyPrimaryKeyMapping, _ = queries.BindMapping(companyType, companyMapping, companyPrimaryKeyColumns)
	companyInsertCacheMut       sync.RWMutex
	companyInsertCache          = make(map[string]insertCache)
	companyUpdateCacheMut       sync.RWMutex
	companyUpdateCache          = make(map[string]updateCache)
	companyUpsertCacheMut       sync.RWMutex
	companyUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var companyBeforeInsertHooks []CompanyHook
var companyBeforeUpdateHooks []CompanyHook
var companyBeforeDeleteHooks []CompanyHook
var companyBeforeUpsertHooks []CompanyHook

var companyAfterInsertHooks []CompanyHook
var companyAfterSelectHooks []CompanyHook
var companyAfterUpdateHooks []CompanyHook
var companyAfterDeleteHooks []CompanyHook
var companyAfterUpsertHooks []CompanyHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Company) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Company) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Company) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Company) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Company) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Company) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Company) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Company) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Company) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range companyAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCompanyHook registers your hook function for all future operations.
func AddCompanyHook(hookPoint boil.HookPoint, companyHook CompanyHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		companyBeforeInsertHooks = append(companyBeforeInsertHooks, companyHook)
	case boil.BeforeUpdateHook:
		companyBeforeUpdateHooks = append(companyBeforeUpdateHooks, companyHook)
	case boil.BeforeDeleteHook:
		companyBeforeDeleteHooks = append(companyBeforeDeleteHooks, companyHook)
	case boil.BeforeUpsertHook:
		companyBeforeUpsertHooks = append(companyBeforeUpsertHooks, companyHook)
	case boil.AfterInsertHook:
		companyAfterInsertHooks = append(companyAfterInsertHooks, companyHook)
	case boil.AfterSelectHook:
		companyAfterSelectHooks = append(companyAfterSelectHooks, companyHook)
	case boil.AfterUpdateHook:
		companyAfterUpdateHooks = append(companyAfterUpdateHooks, companyHook)
	case boil.AfterDeleteHook:
		companyAfterDeleteHooks = append(companyAfterDeleteHooks, companyHook)
	case boil.AfterUpsertHook:
		companyAfterUpsertHooks = append(companyAfterUpsertHooks, companyHook)
	}
}

// One returns a single company record from the query.
func (q companyQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Company, error) {
	o := &Company{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for companies")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Company records from the query.
func (q companyQuery) All(ctx context.Context, exec boil.ContextExecutor) (CompanySlice, error) {
	var o []*Company

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Company slice")
	}

	if len(companyAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Company records in the query.
func (q companyQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count companies rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q companyQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if companies exists")
	}

	return count > 0, nil
}

// Cycle pointed to by the foreign key.
func (o *Company) Cycle(mods ...qm.QueryMod) cycleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.CycleID),
	}

	queryMods = append(queryMods, mods...)

	query := Cycles(queryMods...)
	queries.SetFrom(query.Query, "`cycle`")

	return query
}

// InvoiceForm pointed to by the foreign key.
func (o *Company) InvoiceForm(mods ...qm.QueryMod) invoiceFormQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.InvoiceFormID),
	}

	queryMods = append(queryMods, mods...)

	query := InvoiceForms(queryMods...)
	queries.SetFrom(query.Query, "`invoice_forms`")

	return query
}

// PaymentDate pointed to by the foreign key.
func (o *Company) PaymentDate(mods ...qm.QueryMod) paymentDateQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.PaymentDateID),
	}

	queryMods = append(queryMods, mods...)

	query := PaymentDates(queryMods...)
	queries.SetFrom(query.Query, "`payment_dates`")

	return query
}

// PaymentWay pointed to by the foreign key.
func (o *Company) PaymentWay(mods ...qm.QueryMod) paymentWayQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.PaymentWayID),
	}

	queryMods = append(queryMods, mods...)

	query := PaymentWays(queryMods...)
	queries.SetFrom(query.Query, "`payment_ways`")

	return query
}

// SendWay pointed to by the foreign key.
func (o *Company) SendWay(mods ...qm.QueryMod) sendWayQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.SendWayID),
	}

	queryMods = append(queryMods, mods...)

	query := SendWays(queryMods...)
	queries.SetFrom(query.Query, "`send_ways`")

	return query
}

// LoadCycle allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (companyL) LoadCycle(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompany interface{}, mods queries.Applicator) error {
	var slice []*Company
	var object *Company

	if singular {
		object = maybeCompany.(*Company)
	} else {
		slice = *maybeCompany.(*[]*Company)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &companyR{}
		}
		if !queries.IsNil(object.CycleID) {
			args = append(args, object.CycleID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &companyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CycleID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CycleID) {
				args = append(args, obj.CycleID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`cycle`),
		qm.WhereIn(`cycle.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Cycle")
	}

	var resultSlice []*Cycle
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Cycle")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for cycle")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cycle")
	}

	if len(companyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Cycle = foreign
		if foreign.R == nil {
			foreign.R = &cycleR{}
		}
		foreign.R.Companies = append(foreign.R.Companies, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CycleID, foreign.ID) {
				local.R.Cycle = foreign
				if foreign.R == nil {
					foreign.R = &cycleR{}
				}
				foreign.R.Companies = append(foreign.R.Companies, local)
				break
			}
		}
	}

	return nil
}

// LoadInvoiceForm allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (companyL) LoadInvoiceForm(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompany interface{}, mods queries.Applicator) error {
	var slice []*Company
	var object *Company

	if singular {
		object = maybeCompany.(*Company)
	} else {
		slice = *maybeCompany.(*[]*Company)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &companyR{}
		}
		if !queries.IsNil(object.InvoiceFormID) {
			args = append(args, object.InvoiceFormID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &companyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InvoiceFormID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InvoiceFormID) {
				args = append(args, obj.InvoiceFormID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`invoice_forms`),
		qm.WhereIn(`invoice_forms.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load InvoiceForm")
	}

	var resultSlice []*InvoiceForm
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice InvoiceForm")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for invoice_forms")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for invoice_forms")
	}

	if len(companyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InvoiceForm = foreign
		if foreign.R == nil {
			foreign.R = &invoiceFormR{}
		}
		foreign.R.Companies = append(foreign.R.Companies, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InvoiceFormID, foreign.ID) {
				local.R.InvoiceForm = foreign
				if foreign.R == nil {
					foreign.R = &invoiceFormR{}
				}
				foreign.R.Companies = append(foreign.R.Companies, local)
				break
			}
		}
	}

	return nil
}

// LoadPaymentDate allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (companyL) LoadPaymentDate(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompany interface{}, mods queries.Applicator) error {
	var slice []*Company
	var object *Company

	if singular {
		object = maybeCompany.(*Company)
	} else {
		slice = *maybeCompany.(*[]*Company)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &companyR{}
		}
		if !queries.IsNil(object.PaymentDateID) {
			args = append(args, object.PaymentDateID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &companyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentDateID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PaymentDateID) {
				args = append(args, obj.PaymentDateID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`payment_dates`),
		qm.WhereIn(`payment_dates.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentDate")
	}

	var resultSlice []*PaymentDate
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentDate")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for payment_dates")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment_dates")
	}

	if len(companyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PaymentDate = foreign
		if foreign.R == nil {
			foreign.R = &paymentDateR{}
		}
		foreign.R.Companies = append(foreign.R.Companies, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PaymentDateID, foreign.ID) {
				local.R.PaymentDate = foreign
				if foreign.R == nil {
					foreign.R = &paymentDateR{}
				}
				foreign.R.Companies = append(foreign.R.Companies, local)
				break
			}
		}
	}

	return nil
}

// LoadPaymentWay allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (companyL) LoadPaymentWay(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompany interface{}, mods queries.Applicator) error {
	var slice []*Company
	var object *Company

	if singular {
		object = maybeCompany.(*Company)
	} else {
		slice = *maybeCompany.(*[]*Company)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &companyR{}
		}
		if !queries.IsNil(object.PaymentWayID) {
			args = append(args, object.PaymentWayID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &companyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PaymentWayID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PaymentWayID) {
				args = append(args, obj.PaymentWayID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`payment_ways`),
		qm.WhereIn(`payment_ways.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PaymentWay")
	}

	var resultSlice []*PaymentWay
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PaymentWay")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for payment_ways")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment_ways")
	}

	if len(companyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PaymentWay = foreign
		if foreign.R == nil {
			foreign.R = &paymentWayR{}
		}
		foreign.R.Companies = append(foreign.R.Companies, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PaymentWayID, foreign.ID) {
				local.R.PaymentWay = foreign
				if foreign.R == nil {
					foreign.R = &paymentWayR{}
				}
				foreign.R.Companies = append(foreign.R.Companies, local)
				break
			}
		}
	}

	return nil
}

// LoadSendWay allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (companyL) LoadSendWay(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompany interface{}, mods queries.Applicator) error {
	var slice []*Company
	var object *Company

	if singular {
		object = maybeCompany.(*Company)
	} else {
		slice = *maybeCompany.(*[]*Company)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &companyR{}
		}
		if !queries.IsNil(object.SendWayID) {
			args = append(args, object.SendWayID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &companyR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SendWayID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SendWayID) {
				args = append(args, obj.SendWayID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`send_ways`),
		qm.WhereIn(`send_ways.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load SendWay")
	}

	var resultSlice []*SendWay
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice SendWay")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for send_ways")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for send_ways")
	}

	if len(companyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SendWay = foreign
		if foreign.R == nil {
			foreign.R = &sendWayR{}
		}
		foreign.R.Companies = append(foreign.R.Companies, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SendWayID, foreign.ID) {
				local.R.SendWay = foreign
				if foreign.R == nil {
					foreign.R = &sendWayR{}
				}
				foreign.R.Companies = append(foreign.R.Companies, local)
				break
			}
		}
	}

	return nil
}

// SetCycle of the company to the related item.
// Sets o.R.Cycle to related.
// Adds o to related.R.Companies.
func (o *Company) SetCycle(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Cycle) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `companies` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"cycle_id"}),
		strmangle.WhereClause("`", "`", 0, companyPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CycleID, related.ID)
	if o.R == nil {
		o.R = &companyR{
			Cycle: related,
		}
	} else {
		o.R.Cycle = related
	}

	if related.R == nil {
		related.R = &cycleR{
			Companies: CompanySlice{o},
		}
	} else {
		related.R.Companies = append(related.R.Companies, o)
	}

	return nil
}

// RemoveCycle relationship.
// Sets o.R.Cycle to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Company) RemoveCycle(ctx context.Context, exec boil.ContextExecutor, related *Cycle) error {
	var err error

	queries.SetScanner(&o.CycleID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("cycle_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Cycle = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Companies {
		if queries.Equal(o.CycleID, ri.CycleID) {
			continue
		}

		ln := len(related.R.Companies)
		if ln > 1 && i < ln-1 {
			related.R.Companies[i] = related.R.Companies[ln-1]
		}
		related.R.Companies = related.R.Companies[:ln-1]
		break
	}
	return nil
}

// SetInvoiceForm of the company to the related item.
// Sets o.R.InvoiceForm to related.
// Adds o to related.R.Companies.
func (o *Company) SetInvoiceForm(ctx context.Context, exec boil.ContextExecutor, insert bool, related *InvoiceForm) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `companies` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"invoice_form_id"}),
		strmangle.WhereClause("`", "`", 0, companyPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InvoiceFormID, related.ID)
	if o.R == nil {
		o.R = &companyR{
			InvoiceForm: related,
		}
	} else {
		o.R.InvoiceForm = related
	}

	if related.R == nil {
		related.R = &invoiceFormR{
			Companies: CompanySlice{o},
		}
	} else {
		related.R.Companies = append(related.R.Companies, o)
	}

	return nil
}

// RemoveInvoiceForm relationship.
// Sets o.R.InvoiceForm to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Company) RemoveInvoiceForm(ctx context.Context, exec boil.ContextExecutor, related *InvoiceForm) error {
	var err error

	queries.SetScanner(&o.InvoiceFormID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("invoice_form_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InvoiceForm = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Companies {
		if queries.Equal(o.InvoiceFormID, ri.InvoiceFormID) {
			continue
		}

		ln := len(related.R.Companies)
		if ln > 1 && i < ln-1 {
			related.R.Companies[i] = related.R.Companies[ln-1]
		}
		related.R.Companies = related.R.Companies[:ln-1]
		break
	}
	return nil
}

// SetPaymentDate of the company to the related item.
// Sets o.R.PaymentDate to related.
// Adds o to related.R.Companies.
func (o *Company) SetPaymentDate(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PaymentDate) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `companies` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"payment_date_id"}),
		strmangle.WhereClause("`", "`", 0, companyPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PaymentDateID, related.ID)
	if o.R == nil {
		o.R = &companyR{
			PaymentDate: related,
		}
	} else {
		o.R.PaymentDate = related
	}

	if related.R == nil {
		related.R = &paymentDateR{
			Companies: CompanySlice{o},
		}
	} else {
		related.R.Companies = append(related.R.Companies, o)
	}

	return nil
}

// RemovePaymentDate relationship.
// Sets o.R.PaymentDate to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Company) RemovePaymentDate(ctx context.Context, exec boil.ContextExecutor, related *PaymentDate) error {
	var err error

	queries.SetScanner(&o.PaymentDateID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("payment_date_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.PaymentDate = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Companies {
		if queries.Equal(o.PaymentDateID, ri.PaymentDateID) {
			continue
		}

		ln := len(related.R.Companies)
		if ln > 1 && i < ln-1 {
			related.R.Companies[i] = related.R.Companies[ln-1]
		}
		related.R.Companies = related.R.Companies[:ln-1]
		break
	}
	return nil
}

// SetPaymentWay of the company to the related item.
// Sets o.R.PaymentWay to related.
// Adds o to related.R.Companies.
func (o *Company) SetPaymentWay(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PaymentWay) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `companies` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"payment_way_id"}),
		strmangle.WhereClause("`", "`", 0, companyPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PaymentWayID, related.ID)
	if o.R == nil {
		o.R = &companyR{
			PaymentWay: related,
		}
	} else {
		o.R.PaymentWay = related
	}

	if related.R == nil {
		related.R = &paymentWayR{
			Companies: CompanySlice{o},
		}
	} else {
		related.R.Companies = append(related.R.Companies, o)
	}

	return nil
}

// RemovePaymentWay relationship.
// Sets o.R.PaymentWay to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Company) RemovePaymentWay(ctx context.Context, exec boil.ContextExecutor, related *PaymentWay) error {
	var err error

	queries.SetScanner(&o.PaymentWayID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("payment_way_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.PaymentWay = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Companies {
		if queries.Equal(o.PaymentWayID, ri.PaymentWayID) {
			continue
		}

		ln := len(related.R.Companies)
		if ln > 1 && i < ln-1 {
			related.R.Companies[i] = related.R.Companies[ln-1]
		}
		related.R.Companies = related.R.Companies[:ln-1]
		break
	}
	return nil
}

// SetSendWay of the company to the related item.
// Sets o.R.SendWay to related.
// Adds o to related.R.Companies.
func (o *Company) SetSendWay(ctx context.Context, exec boil.ContextExecutor, insert bool, related *SendWay) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `companies` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"send_way_id"}),
		strmangle.WhereClause("`", "`", 0, companyPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SendWayID, related.ID)
	if o.R == nil {
		o.R = &companyR{
			SendWay: related,
		}
	} else {
		o.R.SendWay = related
	}

	if related.R == nil {
		related.R = &sendWayR{
			Companies: CompanySlice{o},
		}
	} else {
		related.R.Companies = append(related.R.Companies, o)
	}

	return nil
}

// RemoveSendWay relationship.
// Sets o.R.SendWay to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Company) RemoveSendWay(ctx context.Context, exec boil.ContextExecutor, related *SendWay) error {
	var err error

	queries.SetScanner(&o.SendWayID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("send_way_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SendWay = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Companies {
		if queries.Equal(o.SendWayID, ri.SendWayID) {
			continue
		}

		ln := len(related.R.Companies)
		if ln > 1 && i < ln-1 {
			related.R.Companies[i] = related.R.Companies[ln-1]
		}
		related.R.Companies = related.R.Companies[:ln-1]
		break
	}
	return nil
}

// Companies retrieves all the records using an executor.
func Companies(mods ...qm.QueryMod) companyQuery {
	mods = append(mods, qm.From("`companies`"))
	return companyQuery{NewQuery(mods...)}
}

// FindCompany retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCompany(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*Company, error) {
	companyObj := &Company{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `companies` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, companyObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from companies")
	}

	if err = companyObj.doAfterSelectHooks(ctx, exec); err != nil {
		return companyObj, err
	}

	return companyObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Company) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no companies provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(companyColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	companyInsertCacheMut.RLock()
	cache, cached := companyInsertCache[key]
	companyInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			companyAllColumns,
			companyColumnsWithDefault,
			companyColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(companyType, companyMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(companyType, companyMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `companies` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `companies` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `companies` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, companyPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into companies")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == companyMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for companies")
	}

CacheNoHooks:
	if !cached {
		companyInsertCacheMut.Lock()
		companyInsertCache[key] = cache
		companyInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Company.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Company) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	companyUpdateCacheMut.RLock()
	cache, cached := companyUpdateCache[key]
	companyUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			companyAllColumns,
			companyPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update companies, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `companies` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, companyPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(companyType, companyMapping, append(wl, companyPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update companies row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for companies")
	}

	if !cached {
		companyUpdateCacheMut.Lock()
		companyUpdateCache[key] = cache
		companyUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q companyQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for companies")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for companies")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CompanySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), companyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `companies` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, companyPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in company slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all company")
	}
	return rowsAff, nil
}

var mySQLCompanyUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Company) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no companies provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(companyColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCompanyUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	companyUpsertCacheMut.RLock()
	cache, cached := companyUpsertCache[key]
	companyUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			companyAllColumns,
			companyColumnsWithDefault,
			companyColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			companyAllColumns,
			companyPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert companies, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`companies`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `companies` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(companyType, companyMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(companyType, companyMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for companies")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == companyMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(companyType, companyMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for companies")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for companies")
	}

CacheNoHooks:
	if !cached {
		companyUpsertCacheMut.Lock()
		companyUpsertCache[key] = cache
		companyUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Company record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Company) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Company provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), companyPrimaryKeyMapping)
	sql := "DELETE FROM `companies` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from companies")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for companies")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q companyQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no companyQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from companies")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for companies")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CompanySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(companyBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), companyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `companies` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, companyPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from company slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for companies")
	}

	if len(companyAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Company) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCompany(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CompanySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CompanySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), companyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `companies`.* FROM `companies` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, companyPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CompanySlice")
	}

	*o = slice

	return nil
}

// CompanyExists checks if the Company row exists.
func CompanyExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `companies` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if companies exists")
	}

	return exists, nil
}
